package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {:
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK,
	LBRACE, RBRACE, DOT, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE,
	GT, GE, AND, OR, ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO,
	DO, LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal Absyn.Exp          Exp;
non terminal Absyn.ExpList			ExpList;
non terminal Absyn.ArrayExp			ArrayExp;
non terminal Absyn.AssignExp		AssignExp;
non terminal Absyn.OpExp				OpExp;
non terminal Absyn.SeqExp				SeqExp;
non terminal Absyn.IfExp				IfExp;
non terminal Absyn.Exp 					ElseExp;
non terminal Absyn.Var          Var;

non terminal Absyn.VarDec				VarDec;
non terminal Absyn.Dec					Dec;
non terminal Absyn.DecList			DecList;
non terminal Absyn.TypeDec			TypeDec;
non terminal Absyn.TypeDec			NextTypeDec;
non terminal Absyn.FunctionDec	FunctionDec;
non terminal Absyn.FunctionDec 	NextFunctionDec;
non terminal Absyn.NameTy				NameTy;
non terminal Absyn.Ty 					Ty;
non terminal Absyn.FieldList		FieldList;
non terminal Absyn.FieldList 		NextFieldList;
non terminal Absyn.FieldVar			FieldVar;
non terminal Absyn.SubscriptVar	SubscriptVar;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence nonassoc EQ, NEQ, LT, LE, GT, GE;

start with Exp;

/* EXPRESSIONS */

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	| STRING:s
		{: RESULT = new Absyn.StringExp(sleft, s); :}
	| INT:i
		{: RESULT = new Absyn.IntExp(ileft, i); :}
	| NIL:n
		{: RESULT = new Absyn.NilExp(nleft); :}
	| BREAK:b
		{: RESULT = new Absyn.BreakExp(bleft); :}
	| ArrayExp:arr
		{: RESULT = arr; :}
	| AssignExp:a
		{: RESULT = a; :}
	| SeqExp:s
		{: RESULT = s; :}
	;

ExpList ::=
		{: RESULT = null; :}
	| Exp:e
		{: RESULT = new Absyn.ExpList(e, null); :}
	| Exp:e ExpList:l
		{: RESULT = new Absyn.ExpList(e, l); :}
	;

ArrayExp ::= ID:n LBRACK Exp:e1 RBRACK OF Exp:e2
		{: RESULT = new Absyn.ArrayExp(nleft, sym(n), e1, e2); :}
	;

AssignExp ::= Var:v ASSIGN Exp:e
		{: RESULT = new Absyn.AssignExp(vleft, v, e); :}
	;

SeqExp ::= LPAREN:n Exp:e SEMICOLON ExpList:l RPAREN
		{: RESULT = new Absyn.SeqExp(nleft, l); :}
	;


OpExp ::= Exp:e1 PLUS Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.PLUS, e2); :}
	| Exp:e1 MINUS Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.MINUS, e2); :}
	| Exp:e1 TIMES Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.MUL, e2); :}
	| Exp:e1 DIVIDE Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.DIV, e2); :}
	| Exp:e1 GT Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.GT, e2); :}
	| Exp:e1 GE Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.GE, e2); :}
	| Exp:e1 LT Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.LT, e2); :}
	| Exp:e1 LE Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.LE, e2); :}
	| Exp:e1 EQ Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.EQ, e2); :}
	| Exp:e1 NEQ Exp:e2
		{: RESULT = new Absyn.OpExp(e1left, e1, Absyn.OpExp.NE, e2); :}
	| MINUS:m Exp:e
		{: RESULT = new Absyn.OpExp(mleft, new Absyn.IntExp(mleft, 0), Absyn.OpExp.MINUS, e); :}
	;

IfExp ::= IF:i Exp:e1 THEN Exp:e2 ElseExp:e3
		{: RESULT = new Absyn.IfExp(ileft, e1, e2, e3); :}
	;

ElseExp ::=
		{: RESULT = null; :}
	| ELSE Exp:e1
		{: RESULT = e1; :}
	;

/* DECLARATIONS */

DecList ::= Dec:d
		{: RESULT = new Absyn.DecList(d, null); :}
	| Dec:d DecList:l
		{: RESULT = new Absyn.DecList(d, l); :}
	;

Dec ::= TypeDec:t
		{: RESULT = t; :}
	| VarDec:v
		{: RESULT = v; :}
	| FunctionDec:f
		{: RESULT = f; :}
	;

VarDec ::= Var:v ID:n ASSIGN Exp:e
		{: RESULT = new Absyn.VarDec(vleft, sym(n), null, e); :}
	|	Var:v ID:n NameTy:t ASSIGN Exp:e
		{: RESULT = new Absyn.VarDec(vleft, sym(n), t, e); :}
	;

FunctionDec ::= FUNCTION:fun ID:n LPAREN FieldList:f RPAREN EQ Exp:e NextFunctionDec:next
		{: RESULT = new Absyn.FunctionDec(funleft, sym(n), f, null, e, next); :}
	| FUNCTION:fun ID:n LPAREN FieldList:f RPAREN COLON NameTy:t EQ Exp:e NextFunctionDec:next
		{: RESULT = new Absyn.FunctionDec(funleft, sym(n), f, t, e, next); :}
	;

NextFunctionDec ::=
		{: RESULT = null; :}
	| FunctionDec:fun
		{: RESULT = fun; :}
	;

TypeDec ::= TYPE:t ID:n EQ Ty:v NextTypeDec:next
		{: RESULT = new Absyn.TypeDec(tleft, sym(n), v, next); :}
	;

NextTypeDec ::=
		{: RESULT = null; :}
	| TypeDec:t
		{: RESULT = t; :}
	;

/* TYPES and FIELDS */

Ty ::= ID:n
		{: RESULT = new Absyn.NameTy(nleft, sym(n)); :}
	| LBRACE FieldList:f RBRACE
		{: RESULT = new Absyn.RecordTy(fleft, f); :}
	| ARRAY:a OF ID:n
		{: RESULT = new Absyn.ArrayTy(aleft, sym(n)); :}
	;

FieldList ::=
		{: RESULT = null; :}
	| ID:i1 COLON ID:i2 NextFieldList:f
		{: RESULT = new Absyn.FieldList(i1left, sym(i1), sym(i2), f); :}
	;

NextFieldList ::=
		{: RESULT = null; :}
	| COMMA:c ID:n1 COLON ID:n2 NextFieldList:next
		{: RESULT = new Absyn.FieldList(cleft, sym(n1), sym(n2), next); :}
	;


/* VARIABLES */

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	|	FieldVar:fv
		{: RESULT = fv; :}
	|	SubscriptVar:sv
		{: RESULT = sv; :}
	;

FieldVar ::= Var:v DOT:d ID:n
		{: RESULT = new Absyn.FieldVar(dleft, v, sym(n)); :}
		;

SubscriptVar ::= ID:n LBRACK:l Exp:e RBRACK:r
		{: RESULT = new Absyn.SubscriptVar(lleft, new Absyn.SimpleVar(nleft, sym(n)), e); :}
	|	FieldVar:fv LBRACK:l Exp:e RBRACK:r
		{: RESULT = new Absyn.SubscriptVar(lleft, fv, e); :}
	|	SubscriptVar:sv LBRACK:l Exp:e RBRACK:r
		{: RESULT = new Absyn.SubscriptVar(lleft, sv, e); :}
	;


/* Declarations */
Dec ::= VarDec:v
    {: RESULT = v; :}
	|		FunctionDec:func
    {: RESULT = func; :}
	| 	TypeDec:t
    {: RESULT = t; :}
;
