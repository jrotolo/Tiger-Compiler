package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {:
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK,
	LBRACE, RBRACE, DOT, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE,
	GT, GE, AND, OR, ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO,
	DO, LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal Absyn.Exp          Exp;
non terminal Absyn.ArrayExp			ArrayExp;
non terminal Absyn.AssignExp		AssignExp;
non terminal Absyn.Var          Var;
non terminal Absyn.VarDec				VarDec;
non terminal Absyn.Dec					Dec;
non terminal Absyn.DecList			DecList;
non terminal Absyn.TypeDec			TypeDec;
non terminal Absyn.TypeDec			NextTypeDec;
non terminal Absyn.FunctionDec	FunctionDec;
non terminal Absyn.NameTy				NameTy;
non terminal Absyn.Ty 					Ty;
non terminal Absyn.FieldList		FieldList;

start with Exp;

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	| STRING:s
		{: RESULT = new Absyn.StringExp(sleft, s); :}
	| INT:i
		{: RESULT = new Absyn.IntExp(ileft, i); :}
	| NIL:n
		{: RESULT = new Absyn.NilExp(nleft); :}
	| BREAK:b
		{: RESULT = new Absyn.BreakExp(bleft); :}
	| ArrayExp:arr
		{: RESULT = arr; :}
	| AssignExp:a
		{: RESULT = a; :}
	;

ArrayExp ::= ID:n LBRACK Exp:e1 RBRACK OF Exp:e2
		{: RESULT = new Absyn.ArrayExp(nleft, sym(n), e1, e2); :}
	;

AssignExp ::= Var:v ASSIGN Exp:e
		{: RESULT = new Absyn.AssignExp(vleft, v, e); :}
	;

DecList ::= Dec:d
		{: RESULT = new Absyn.DecList(d, null); :}
	| Dec:d DecList:l
		{: RESULT = new Absyn.DecList(d, l); :}
	;

Dec ::= TypeDec:t
		{: RESULT = t; :}
	| VarDec:v
		{: RESULT = v; :}
	| FunctionDec:f
		{: RESULT = f; :}
	;

VarDec ::= Var:v ID:n ASSIGN Exp:e
		{: RESULT = new Absyn.VarDec(vleft, sym(n), null, e); :}
	|	Var:v ID:n NameTy:t ASSIGN Exp:e
		{: RESULT = new Absyn.VarDec(vleft, sym(n), t, e); :}
	;

TypeDec ::= TYPE:t ID:n EQ Ty:v NextTypeDec:next
		{: RESULT = new Absyn.TypeDec(tleft, sym(n), v, next); :}
	;

NextTypeDec ::=
		{: RESULT = null; :}
	| TypeDec:t
		{: RESULT = t; :}
	;

Ty ::= ID:n
		{: RESULT = new Absyn.NameTy(nleft, sym(n)); :}
	| LBRACE FieldList:f RBRACE
		{: RESULT = new Absyn.RecordTy(fleft, f); :}
	| ARRAY:a OF ID:n
		{: RESULT = new Absyn.ArrayTy(aleft, sym(n)); :}
	;

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	;
