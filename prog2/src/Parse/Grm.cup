package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {:
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK,
	LBRACE, RBRACE, DOT, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE,
	GT, GE, AND, OR, ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO,
	DO, LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal Absyn.Exp          Exp;
non terminal Absyn.Var          Var;
non terminal Absyn.Dec 					Dec;
non terminal Absyn.VarDec				VarDec;
non terminal Absyn.FunctionDec  FunctionDec;
non terminal Absyn.TypeDec			TypeDec;
non terminal Absyn.FieldVar			FieldVar;
non terminal Absyn.SubscriptVar	SubscriptVar;


start with Exp;

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	;

/* Variables */
Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	|	FieldVar:fv
		{: RESULT = fv; :}
	|	SubscriptVar:sv
		{: RESULT = sv; :}
	;

FieldVar ::= Var:v DOT:d ID:n
		{: RESULT = new Absyn.FieldVar(dleft, v, sym(n)); :}
		;

SubscriptVar ::= ID:n LBRACK:l Exp:e RBRACK:r
		{: RESULT = new Absyn.SubscriptVar(lleft, new Absyn.SimpleVar(nleft, sym(n)), e); :}
	|	FieldVar:fv LBRACK:l Exp:e RBRACK:r
		{: RESULT = new Absyn.SubscriptVar(lleft, fv, e); :}
	|	SubscriptVar:sv LBRACK:l Exp:e RBRACK:r
		{: RESULT = new Absyn.SubscriptVar(lleft, sv, e); :}
	;


/* Declarations */
Dec ::= VarDec:v
    {: RESULT = v; :}
	|		FunctionDec:func
    {: RESULT = func; :}
	| 	TypeDec:t
    {: RESULT = t; :}
;
